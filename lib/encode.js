'use strict'

const TAG = 0x01
const END = 0x00
const OVERFLOWS_LINE = 0xff
const MAX_FOR_LINE = 0xfe
const OFFSET = 1

function rleEncoder (array, tag) {
  tag = tag || TAG
  let encodedArray = [tag] // starts with the tag
  for (let i = 0; i < array.length; i++) {
    var currentVal = array[i]
    var numberOfEqualValues = 1
    while (currentVal === array[i + numberOfEqualValues]) {
      numberOfEqualValues++
    }

    // if only repeated once or twice just push the number
    // if repeaters push number tag and repeated amount
    // if repeaters are larger than OVERFLOWS_LINE than
    // split them up in values that max out to MAX_FOR_LINE
    //
    // Confusing: starts counting at 1 so
    // 3 repeated 3 times becomes:
    //          3 tag 2
    if (numberOfEqualValues === 1 || numberOfEqualValues === 2) {
      let newArray = new Array(numberOfEqualValues)
      newArray.fill(currentVal)
      encodedArray = encodedArray.concat(newArray)
    } else if (numberOfEqualValues > 2 && numberOfEqualValues < OVERFLOWS_LINE) {
      encodedArray = encodedArray.concat([currentVal, tag, numberOfEqualValues - OFFSET])
    } else if (numberOfEqualValues > 2 && numberOfEqualValues > MAX_FOR_LINE) {
      let remainder = numberOfEqualValues

      // split it into pieces of MAX_FOR_LINE
      while ((remainder - MAX_FOR_LINE) > 2) {
        encodedArray = encodedArray.concat([currentVal, tag, MAX_FOR_LINE])
        remainder = remainder - OVERFLOWS_LINE
      }

      // add the remainder to the list
      if (numberOfEqualValues === 1 || numberOfEqualValues === 2) {
        let newArray = new Array(numberOfEqualValues)
        newArray.fill(currentVal)
        encodedArray = encodedArray.concat(newArray)
      } else {
        encodedArray = encodedArray.concat([currentVal, tag, remainder - OFFSET])
      }
    }

    i = (numberOfEqualValues > 1) ? i + numberOfEqualValues - 1 : i
  }
  encodedArray.push(tag)
  encodedArray.push(END)
  return encodedArray
}

module.exports = rleEncoder

// Based on Shiru's RLE for the NES
//
// First byte {1} is a unique byte, called “tag”.
// Next byte {2} is a tile to go to the nametable.
// If the next byte {3} is the “tag” then
// the following byte {4} is how many more repeats.
// If the next byte {3} is not the “tag” then
// the that byte {3} becomes the next new value (tile).
//
//  If the byte after “tag” {4} is a zero (zero repeats), then that is an End Of File marker, and it exits.…the “tag” value appears to be the first unused tile value, generated by the NES Screen Tool.
//
